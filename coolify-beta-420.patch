--- /home/dark/Apps/coolify-mcp-enhanced/dist/lib/coolify-client.js.backup	2025-08-21 15:41:57.931805671 +0700
+++ /home/dark/Apps/coolify-mcp-enhanced/dist/lib/coolify-client.js	2025-08-22 17:30:58.632636235 +0700
@@ -100,12 +100,36 @@
     async getProjectEnvironment(projectUuid, environmentNameOrUuid) {
         return this.request(`/projects/${projectUuid}/${environmentNameOrUuid}`);
     }
+    // Application Control
     async deployApplication(uuid) {
-        const response = await this.request(`/applications/${uuid}/deploy`, {
+        // L'endpoint correct est /start, pas /deploy
+        const response = await this.request(`/applications/${uuid}/start`, {
             method: 'POST',
+            body: '{}'
         });
         return response;
     }
+    
+    async stopApplication(uuid) {
+        const response = await this.request(`/applications/${uuid}/stop`, {
+            method: 'POST',
+            body: '{}'
+        });
+        return response;
+    }
+    
+    async restartApplication(uuid) {
+        const response = await this.request(`/applications/${uuid}/restart`, {
+            method: 'POST',
+            body: '{}'
+        });
+        return response;
+    }
+    
+    async startApplication(uuid) {
+        // Alias pour deployApplication
+        return this.deployApplication(uuid);
+    }
     async listDatabases() {
         return this.request('/databases');
     }
@@ -220,9 +244,83 @@
         return this.request(`/applications/${uuid}/envs`);
     }
     async updateApplicationEnvironmentVariables(uuid, variables) {
-        return this.request(`/applications/${uuid}/envs`, {
-            method: 'POST',
-            body: JSON.stringify(variables),
+        // Si c'est un array, on traite chaque variable
+        if (Array.isArray(variables)) {
+            const results = [];
+            for (const variable of variables) {
+                try {
+                    // D'abord essayer PATCH (pour update)
+                    const patchPayload = {
+                        key: variable.key,
+                        value: variable.value
+                    };
+                    if (variable.is_preview !== undefined) patchPayload.is_preview = variable.is_preview;
+                    if (variable.is_build_time !== undefined) patchPayload.is_build_time = variable.is_build_time;
+                    if (variable.is_literal !== undefined) patchPayload.is_literal = variable.is_literal;
+                    
+                    try {
+                        // Essayer de mettre à jour
+                        const result = await this.request(`/applications/${uuid}/envs`, {
+                            method: 'PATCH',
+                            body: JSON.stringify(patchPayload),
+                        });
+                        results.push({ action: 'updated', ...result });
+                    } catch (patchError) {
+                        // Si PATCH échoue, essayer POST (pour créer)
+                        if (patchError.message && patchError.message.includes('not found')) {
+                            const postPayload = {
+                                key: variable.key,
+                                value: variable.value
+                            };
+                            if (variable.is_preview !== undefined) postPayload.is_preview = variable.is_preview;
+                            if (variable.is_build_time !== undefined) postPayload.is_build_time = variable.is_build_time;
+                            if (variable.is_literal !== undefined) postPayload.is_literal = variable.is_literal;
+                            
+                            const result = await this.request(`/applications/${uuid}/envs`, {
+                                method: 'POST',
+                                body: JSON.stringify(postPayload),
+                            });
+                            results.push({ action: 'created', ...result });
+                        } else {
+                            throw patchError;
+                        }
+                    }
+                } catch (error) {
+                    results.push({ error: error.message, key: variable.key });
+                }
+            }
+            return { message: 'Batch operation completed', results };
+        } else {
+            // Si c'est un objet simple, essayer PATCH d'abord, puis POST si ça échoue
+            const payload = {
+                key: variables.key,
+                value: variables.value
+            };
+            if (variables.is_preview !== undefined) payload.is_preview = variables.is_preview;
+            if (variables.is_build_time !== undefined) payload.is_build_time = variables.is_build_time;
+            if (variables.is_literal !== undefined) payload.is_literal = variables.is_literal;
+            
+            try {
+                // Essayer de mettre à jour
+                return await this.request(`/applications/${uuid}/envs`, {
+                    method: 'PATCH',
+                    body: JSON.stringify(payload),
+                });
+            } catch (patchError) {
+                // Si ça échoue, essayer de créer
+                if (patchError.message && patchError.message.includes('not found')) {
+                    return await this.request(`/applications/${uuid}/envs`, {
+                        method: 'POST',
+                        body: JSON.stringify(payload),
+                    });
+                }
+                throw patchError;
+            }
+        }
+    }
+    async deleteApplicationEnvironmentVariable(appUuid, varUuid) {
+        return this.request(`/applications/${appUuid}/envs/${varUuid}`, {
+            method: 'DELETE',
         });
     }
     // Docker Compose Service Management
@@ -239,17 +337,72 @@
         });
     }
     // Deployment Management
+        // Deployment Management
     async getDeployments(applicationUuid) {
-        return this.request(`/applications/${applicationUuid}/deployments`);
+        // L'endpoint correct utilise un query param
+        return this.request(`/deployments?application_uuid=${applicationUuid}`);
     }
+    
     async getDeployment(uuid) {
         return this.request(`/deployments/${uuid}`);
     }
+    
     async cancelDeployment(uuid) {
         return this.request(`/deployments/${uuid}/cancel`, {
             method: 'POST',
+            body: '{}'
         });
     }
+    
+    async getBuildLogs(uuid) {
+        // Utilise les logs normaux car /logs/build n'existe pas
+        return this.getApplicationLogs(uuid, { type: 'build' });
+    }
+    
+    async getServerMetrics(uuid) {
+        // Utilise getServerResources qui existe déjà
+        return this.getServerResources(uuid);
+    }
+    
+    async getApplicationMetrics(uuid) {
+        // Récupère les métriques via l'application
+        const app = await this.getApplication(uuid);
+        return {
+            status: app.status,
+            server_status: app.server_status,
+            last_online_at: app.last_online_at,
+            limits: {
+                cpu: app.limits_cpus,
+                memory: app.limits_memory,
+                cpu_shares: app.limits_cpu_shares
+            }
+        };
+    }
+    
+    async getDockerContainers(serverUuid) {
+        // Utilise les ressources serveur qui incluent les containers
+        const resources = await this.getServerResources(serverUuid);
+        return resources.containers || [];
+    }
+    
+    async getDockerNetworks(serverUuid) {
+        const resources = await this.getServerResources(serverUuid);
+        return resources.networks || [];
+    }
+    
+    async getDockerVolumes(serverUuid) {
+        const resources = await this.getServerResources(serverUuid);
+        return resources.volumes || [];
+    }
+
+    async getDeploymentStatus(applicationUuid) {
+        // Récupère le dernier déploiement
+        const deployments = await this.getDeployments(applicationUuid);
+        if (deployments && deployments.length > 0) {
+            return deployments[0];
+        }
+        return { status: 'no_deployments' };
+    }
     // Resource Management
     async getApplicationResources(uuid) {
         return this.request(`/applications/${uuid}/resources`);
